<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba43a5da28874466cfed1d255a1dcc2028e2a19709cd34e4a42e7cd777a0bce2bed518baae94fd3404d09c10f276cc0d57c56e7172c060f025847c3808dbd84edf8749fd21d97a63238046ae010f63daf5526320e2a44a47aee2c8d431bab0dfc88380f878a915daa0dc28f48f3d3538ab2a0c5f474147ab076331a577fc294c95d820b2857bd848bc4b9d4baded12ddb98bd0f01af309a5b8191179f90f0961f465192362fbab351e4246711a021b6b87ce924f15d7984f84d64bba6c4997367f60cd8707643c63e07380927ae5d252531baf52ce1266a044ffa43e4c0146ef2c34a3cdf388123b9abef9d79a670e2cc703e227abb41a9e5a36f30795467d0f1664e8641166d589535788b6c65ff860f8e5ce3090ec4d51c9baef337dd54455cfa7bc365c5739c47792bb77575c9e4e211bf483afe345ea27e4d793015eb49ab4d6151eb5767baab2eb25830020d173d095010edd64858f2d6fd0f697f73ee222f7101f1c371a913108cf276f0d3f5222a3449719c1971d07590b141610fdebed56c1cd36a593e8f443d5717b929e195306bf11678204daef47a63fe083e3dd13c6a04d09470de882aa0cadaadcf273644380d9b20bc79713064dcf7420384086803aaaf6ffe3e45aeb6ec98a3a7558128259ff2a3718b31320761ecb317bb1608577f847bf1d3cf5feadf960fa72e72fbaa57dea7510bdf9fd56c94f331f8ce58427d0095d291be97328971e77706b2cbcefbfa3e4cd5c59a1a0bd59addbfab8512c3a8d454e52f355845f9fbe6f6983e1b82848036d1aa2e2719cb60c5558db9cfa4a8a4eb05749ae3ab5ce0845f07a404c6db8c079febaee92644368c23b69fe22e283839dab04d99e329570b563113e195a119ed34b27b11569da5f3d1b2084fd2a172e3fd06a4cb78ca78fa668ef1586ebeb68c2daedb479ae4bf0d010400901ef88377d73e6c957bcc7b18667f791538438a34208637cd770bdc68e7197effb1d6b5b1a8b9f83d8c92ab5637d8f9af55e92eaf3b9212c69c99a7f40a18f36a5d55405f2a46ef2d6365ec6eec32f5e7f8b5dc4b2e6a60a9833aad6b6faa059e2110a82a61333e2da32d7429c63d35a1a699b251c5c41f3821b7cbfd5219fc0ff4fb9f2ee470a5e040633194fb8f02e290c8099606fbf36f7573ccdb30e77f024d35c1fe3861fd7c4cfa760fa94d72cd40a7e6f1a591b6fab970a6f73f022ef29481e7ce3ca491a4e51299f0df234df5ae580afc61d88d0cafd5fdf8208bb4a92f9973c65d61eb3368f27af7b78f60050d2d7deef738c662ae95fe56d0a342a39ac48e7fecb07ba5ace6ae76cb3e3b8a4149d30f15ac3cc7b4074bc81413523709a450d2e5ab8652087e5d28d6006a84d579a9c815454eabec25b8b3384e7051835a5029c2db5544096301edc481fdff0e4f1ee23840b7c116a465637f4dd1b4bc3c41b82a54ea2b958fc1e02033bfb1ce2bcebb0ef4186690a7b032b208a730f22bd38dcde3bd508db0ba6b8b6878ce87d65adab4edf02406be520f2fd6594a69679cb7985c0b7f990ee533e0a8791d5ad3e5dde2226281709ac8fcf28fde9490526b4bee8b500b136ba4e43fa7a79301e0a04f292d55a829d3d7ec4b3676136e2bffeb38777562dd9cb663d9ff1b38da757cd6155023046c1458d08def60b85383e799870b87cc7f7695a627750cbc7dcd2e5dd8047b983d5c9f236e4d7934c010357507229edbaca1a70e09240c728588d12ad37d5751ca7961e13d9ae62f6bef3e82e34b3cc91a4d82a040b8b319a73f559e42350f8aab0d640a7838701086f65b257a20dae96b382e4e9617ecfeee00c6d3de7696ac6925d955afae158246f5fa20f08f46d3f6e1536778c588b7c43917fa27d6619ee8f0184c73c665a227a428974fde29a80bc9e8bf66b337360b2758acb2bdf711d824da051ade3e1d2a688f7c33de798dc8ad810ff8ac6ffe8a057508f341435798c81f00e682ae1755e68a402990d460d212078ec9fe08256b7bc3c4cfa00b8e1b2081e661ff965a371c7956ec583a27d9ac561ec9de4ce7e3c22b73c2d701fc7d7a4630a18a63f6a783595b295fe9910a1169816044c6fafc6561fb904fa7f127eb816a5378230e2748856f7041ad4160c049a695fbe2fb0e7222711cd55993204044968dbe512648fc0946c62e61ea0490fbf8b53d685991790a43dbb6f29c4c79aa64e89da175361420c98f737dce644709320d831ca98272dd2a4d7d6ea880345a0d3fc6c4326176aa9b947573b51465a6417428f8babc468360713e5d2ad846cc8c694bb1dc95d5d7cb3732d124edf93bb6a5d504393681ec4d3fe37a020804f8e0f19ced9ca0dfc31c96547955bf69068e149a850641e5e86f48564f9987969a2787bd9c53f39891e4105f2d87de383b910d06da249ca5360d9ea8a73284b388a47a9b77d2c678c06500885d871c5bff7696966fd60b7b77aa4b84331d152db9e6270a5bafd285cbcba3ad88d5874fe705867c49f21bdd6380cdbd6604a6c24690b879f303fac8b8c9e094c575e5b2cd0ddc8bb99f12201c00949ebb155ad46eaed2118e57617b2584e6b94a5f362b5ed03666e3720c2247f747b3b07a00a80ec2488c4a7c1c7f6fd1088167f9f76eea8b3238f73dfbfee603b9432f38c391f995cba80affd520d84c3778e848a8da64d90acc12977119eca70554b7ef203e69d41f9b3f3b96df419c2158394dee57b8b3f1fc041faf775b2339a376d126c289991e874fb13a1f50bb827df449f43cab3736511fa20ce3276908636301522bd06b9acf62a321057749f271827f27dc5e34660607ac6d65dd16753937e6b418c4796b0000bef5251b6fab78b6f298c8a28c8a2792e7b85cbce53eed29253a2297465853a5ba777881f1380dd38e5712f48e758cd49eee2e2356a1a0f1cbd14353157db70f65531178c55f2059a7d61ffc0fafa5a4b743386333d188ece27e2a3408f62301d46c96df2adaae544d67444ee8a32f20d8b85f930c2f4ef03e0fe224be6ee1a4cf3bbdf74127d0d46a1b3a5b16630baa55d9a4f1b7abd3faf3dcf510b9724ceb87a2df27233f5c54e771437b9ba914719779c9e382a1d63d33b461b29f7699624a9d2e13434971b5743351ce791d684f8e48cdefbc8fb3220e5ec724a19651a0369de8c36feec453f7fc9251cd3fd40dbfb872907edff098a10aaf0e75ec7d6a8c9e8963c2d82cba748e4889e2e742e19c8b3849ddeb4924a8b00a5ef760ae1f291c0d99a114dc01dbc918adb829d6dd16db2694f97f419d811f4767b28a3ed70a9fca7668a09b08dca4b3f874288c57d2cd69d7a612c554b5ce864ab69979d70999ec72f38ee9643a27b28b46a3e0744ac140d284e24218ada19c55b5e7fe48fe9bc7afc7c9d1007ddbf93e32051cd636c179bb1733d1e17245357aebf41d0e3b5e21558580c1ee5041451dfa48bdebfc56dbc8abf71bd6a070ad55b269c93c01959a9af49bfdcdd8f2d16406e61462d332631a04ac8f7648bdaf79a4f8abbbe664375648281c9c26145907a6d8e4d66aaf6c653340f6f2e2244b71c6fcf00362a059577378453f28c69d88daf3c890b27dde562b4fb4876b4be9e73fa9e43547f93b90bc9bb84593bc24440c21b45b52ddffa9dc97b27d73b1d90fe99d3f4f7c6653347326d651431588afd23fe0febed6272377dc9b6fcb771eadb24f8d61732c189202f9f79fe5ccf9c7f3a0c221fb64f6939853bbc38131d311ec6be4600864a59f556d5d3754fe5c91b40b7a54d13154aaedc21de6f6737b4d40c3295022ffc9c57cff0b2805a59837bb867d83c8929e74fa33d763aacdbeeacafac4e819f7e190e064a136bf3288890eeef02d1e5d94617a3c0003131f0e7d2c935ddfc9b059bd6a7d80c98ec3e95b35bfc147fcc2752c70c8e59f298f1790197f236e49257fc8b8e15d3146e5cbfb8aa18125d04b38837fb184a268fbd82bff0988ff143a44c661d70b7b55cdb41ffef408b93dc43d35de570d61603662053913aac18c17e0a54fdd0f69ac66679ae23d5c836c5ee9410778131f00217b42f523c17ea3c14d323ab0226d4c2dc640a7890f60e6e35cdd485406788fb1c20840dc5f93deb31263d891696aa19f1b184418abd50d7939980659c3f1b1ad1c60554547adcca687256ab708d608e6a4457125fa1efb966d45e5ee01e253c05eb4206c19d841355a5d6c5d4f95b3314c63adbe2e8873e549034438ae5eae44dfc5203ed35156239fdbb3ad4df7c566a2737193c21c0492055d1cf2b02b50afd59e849dff0f6153dddf8b46331e8b4d00e4e0704a76870cb61942113d4eeec6bf72cd954a2d5d326ba1a1260a69b484511f0de61d63109f04117b4312869f1e79666ed81b49752421022d08b44105813d4ed1529160922842421904228b8e1c14c133a20678331a0cea769c794aac03dbe671dd3c7ba8518a5b7490411af5ed94f9c4c52dbdc2ff6610f4e655d451377349e0d2f5d172732d22491453f7584053cdd33db9d30a025b738d4fc949d73aa3d02bd317d5237282d814451189cbb3a5323de1f06ede5282805fec3217b38010b527cc7d5e0d1aa34718b2b12fe9137821fb4012378252ff031ce2ba2013e45074f70bb1604a5c97e8dc9d9dbd5ff282fa03ab37712f5847e7dbd0ec0e928989d91b7d83971d272b3f33aed9a88fa46acfddfc72dbae53d2586a9afa9d5f95dd3420c3803b1fe4f93c60b3b2ca5deebdd88cf21896a7c802df6c29ba35df579f627e91d77d7b159247f0faf4f1c48303e8ae36d02ec04c77c8577743f89187291134d383d4089bffc8826576cb1f44b35218a3815ec15d82287a101c1f098973d8ff8f5d1b89f32734fe498ebeadaf7d2e206932b68531cd601cb29228bac7cf4b9e89d3bf2e5ba908ff8b0587900d21b4f6bea5a5b1636a303a81893b0c07689374f9572ef5810d9f28135ca6b6afd13f5f0b9e084ad93be4e21d23fde7bd5dfd483c3ca9e15a900e00829fc79d1e90655fe3ac3aa7daf2a9da25c301965ffa8b1f053f3e471b8d0084294e9eeebbc16d450ee393158080933d75f1fd55b2c4095fc4cc721fa5f12f93b6d6dd208b67e98122811a0cc66dafe6724eb93e149d7800b0ea26c8116f2c9467e70a0cb85dc50f42f45d6421c884d527204039eca94bbc11dda10f8f8e3fbcce8ee3db22f0679f99d707c33d891ba0d06ff3e8a58095d10accc63905374fc9c0620ceb10cd30e1e87c2dc21269927b11d4e9958fbbb3a17814a49ff35c341c1fd708568796fa1b3ffb1d9465aa18b082020a9939c4e4e1f48af68ee6becfc03405fc2373ceb4ef6f8244a2d03ae841396d78c5d2907142e321a4c608b59e2debb074b52305f2f5901bf8de6b9b94e913fba6684964bb96939327e415513ad2cf51f64544c9368ec59b8b3614b2e560ae21eb9d24f7c9de44a474bb1a075b1d19c081acc2ee013c50e8d5376cc4145aa45989cd9495811a17773c771d1cabbe7574ffefbefa38674661e44f1ad71b562bdfa0cc58e2780564e33a6a15cd49fda092eb04b60d6cbc325298975028bd702ed874e8dbcf84db357c36a22f389868265d4f80af39625967aec19f2dcaf54616d13287cfd3c4dbb9f36ba3fb1defcec95edcfa5cfcd19d22d5c987e28a74ce8016f3a485327e71cf50efbe99838b93991e4dd714699273182950b181a91758ff4ded516825ceb232641544d3f403e47c52b2dde02175c47970bdf5ebcf0b9c6ee7ab1e3e08dc1e5a8ec47985e553e3b24a66faad276889e36e2e3e32a048428cf412c6915fc2d021d5da762e37478226347dedb40381613a666bc727d489c18bfae9ba1d81fb814cc920b937b2926be650b33e4c75587881bc0f235245e81661ff89c31864bead59ffe5216f645d3cd23b3dbd00e6c868c4167620b9578275a2a9d2a70a4d02e3b4f82a2d151511c05048418f4fe3e9b68f244255edee0a5f13a10085fff4b0f03a31602b922b32bcc26c919fe48a01d4693c1065be27efc986d46d87ed8fd387b2f770bc17f9aeacecb3a45d1d2e536e4ac8055e1a92c25f921bdc1bad1b6336a6bd6df59153f32529cee98887468727aad51eacd0aa99ab0520f6fa11560919f9553865e2cca7f07c7bc5c5b8e561d08a350fb56fd14207c69fdd72e116291cf5ea64a5867f1345e3d2f74b34d0d3486824e97b06faec95ffb8bdb7256c72643d39a081b46fdc088dc2f11428b4c03a2f6899ad39a5d52008db42588e12095c44f97459305ff7d6eaec669d20b96b1b6a56b7751b608395e50b01dbbe2762a3fcb17dec6d0ce8a82d0b58291acce50b678ad41a3b6167084172c1fb85c39a7797078f4015676e22e55b88c5e9b1e4c83b12c490ae2e5fa3226f7d29f7f5dfcad3ac90ed67be95d4e61ea3be55a82045bf09cc1bfa3b98109d04c7b69116f3ee9d98274eda7a8e787bc79abb8a8113c4ff8754ecc61ab5d97e4de76832668f5dd26192563689bac9621976c7bd335c35509f81d1c3f75cbf101c0d54da3a2a20aa20ed962bb56c425244e3a7bf06578090581f7db1a3241bbd0408783ed0630fa06651e65422d6e03bc1a9a71fba68568d2ff94dc1ddf5d43205db1bc5931420be6af90c05b8d1be3603f01385bfb93e34049cc3eef4d856000078fcc0eac3e3441f1c810416c24757b71bdf4be393dce6a954acbe5edbab012af20f05d6888b4a32cd79018dfa1e4db736e5da5679061dce327dec409598c13304939c56b12c6601b16aa58bf188e6e3e895cbe6f48b0ebfbbdcd6de1577e80d6612d87f415f25910ac3fc344b2e976147862bbfcf4c7d3bdabc1f68eaf71cd7042a225d521ff8b301c8ae29a0f62780186ac1a8cc8b6bffbe7735dd957c9bb46362416f460497cd7a2aad3b978328d29347b3930596579c5ab7eb14ef1783a1dc8998612fa326a97cfde3a623149190e0f424da3bc7dee0436057e68287a5be334b0f8497110e4951d6b565103d89990f9c62d9b4545b271dccaa966e46d19b3b27388e8ccdd358063272abf7fe7a11d36dc8627f37e24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c7a098c42632cd2d4c34248e18ae950a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
